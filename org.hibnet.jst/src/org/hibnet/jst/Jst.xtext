/*******************************************************************************
 * Copyright (c) 2012 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 ******************************************************************************/
grammar org.hibnet.jst.Jst with org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations

generate jst "http://www.hibnet.org/jst/Jst"
import 'http://www.eclipse.org/xtext/xbase/Xbase' as xbase
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types

JstFile:
    {JstFile}
    ('package' package=QualifiedName ';')?
    imports+=Import*
    ( abstract?='abstract'? 'template'
         ('extends' extends=QualifiedName)?
         ('implements' implements+=QualifiedName (',' implements+=QualifiedName)* )?
         ';'
    )?
    (
        fields+=Field
      | methods+=Method
      | templates+=Template
    )*
;

Import:
    'import' static?='static'? (importedNamespace=QualifiedName | importedNamespace=QualifiedNameWithWildCard) ';'
;

Field:
    {Field}
    (visibility=Visibility? & static?='static'? & final?='final'?) type=JvmTypeReference name=ID ('=' initialValue=XExpression)? ';'
;

Method:
    {Method}
    (visibility=Visibility? & (static?='static' | abstract?='abstract')? )
    ('<' typeParameters+=JvmTypeParameter (',' typeParameters+=JvmTypeParameter)* '>')?
    type=JvmTypeReference name=ID
    BRACE_OPEN (parameters+=Parameter (',' parameters+=Parameter)*)? BRACE_CLOSE
    ('throws' exceptions+=JvmTypeReference (',' exceptions+=JvmTypeReference)*)?
    expression=XBlockExpression
;

enum Visibility returns types::JvmVisibility:
    PUBLIC = 'public' | PROTECTED = 'protected' | PRIVATE = 'private';


//////////////////////////////////
// Template things
//////////////////////////////////

Template:
    DIRECTIVE_TEMPLATE name=ID BRACE_OPEN params=Parameters? BRACE_CLOSE
    body=RichString
    DIRECTIVE_END
;

Parameters:
    params+=Parameter (',' params+=Parameter)*
;

Parameter:
    type=JvmTypeReference name=ID
;

RichString returns xbase::XBlockExpression:
    {RichString}
    ( expressions+=RichStringPart
        | DIRECTIVE startScript+=BRACE_OPEN (expressions+=XExpressionInsideBlock ';')* endScript+=BRACE_CLOSE
    )*
;

RichStringPart returns xbase::XExpression:
      RichStringLiteral
    | RichStringInlineExpr
    | RichStringForLoop
    | RichStringIf
;

RichStringLiteral returns xbase::XStringLiteral:
    {RichStringLiteral} value=TEXT
;

RichStringInlineExpr returns xbase::XExpression:
    {RichStringInlineExpr}
    (DIRECTIVE_ECHO | elvis?=DIRECTIVE_ECHO_ELVIS) BRACE_OPEN expr=XExpression BRACE_CLOSE
;

RichStringForLoop returns xbase::XForLoopExpression:
    {RichStringForLoop}
    DIRECTIVE_FOR BRACE_OPEN declaredParam=JvmFormalParameter ':' forExpression=XExpression BRACE_CLOSE
        eachExpression=RichString
    DIRECTIVE_END
;

RichStringIf returns xbase::XIfExpression:
    {RichStringIf}
    DIRECTIVE_IF BRACE_OPEN if=XExpression BRACE_CLOSE
        then=RichString
    (else=RichStringElseIf | DIRECTIVE_ELSE else=RichString)?
    DIRECTIVE_END
;

RichStringElseIf returns xbase::XIfExpression:
    {RichStringIf}
    DIRECTIVE_ELSEIF BRACE_OPEN if=XExpression BRACE_CLOSE
        then=RichString
    (else=RichStringElseIf | DIRECTIVE_ELSE else=RichString)?
;

QualifiedNameWithWildCard :
    QualifiedName  '.' '*';

terminal BRACE_OPEN: '(';
terminal BRACE_CLOSE: ')';

terminal DIRECTIVE_TEMPLATE: '#template';
terminal DIRECTIVE_IF: '#if';
terminal DIRECTIVE_ELSE: '#else';
terminal DIRECTIVE_ELSEIF: '#elseif';
terminal DIRECTIVE_END: '#end';
terminal DIRECTIVE_FOR: '#for';
terminal DIRECTIVE: '#';
terminal DIRECTIVE_ECHO: '$';
terminal DIRECTIVE_ECHO_ELVIS: '$!';

terminal TEXT:
// we fake the generated parser so it never match it and we can handle it ourself
    '\uAAAA'
// actual expected form:
//    ( (!('#'|'$')) | '##' | '$$')*
;
