/*******************************************************************************
 * Copyright (c) 2012 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 ******************************************************************************/
grammar org.hibnet.jst.Jst with org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations

generate jst "http://www.hibnet.org/jst/Jst"
import 'http://www.eclipse.org/xtext/xbase/Xbase' as xbase
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types

JstFile returns types::JvmGenericType:
    {JstFile}
    ('package' packageName=QualifiedName ';')?
    imports+=Import*
    ( abstract?='abstract'? 'template'
         ('extends' superTypes+=JvmParameterizedTypeReference)?
         ('implements' superTypes+=JvmParameterizedTypeReference (',' superTypes+=JvmParameterizedTypeReference)* )?
         ';'
    )?
    (
        members+=Field
      | members+=Method
      | members+=Template
    )*
;

Import:
    'import' static?='static'? (importedNamespace=QualifiedName | importedNamespace=QualifiedNameWithWildCard) ';'
;

Field returns types::JvmField:
    {Field}
    (visibility=Visibility? & static?='static'? & final?='final'?) type=JvmTypeReference simpleName=ID ('=' initialValue=XExpression)? ';'
;

Method returns types::JvmOperation:
    {Method}
    (visibility=Visibility? & (static?='static' | abstract?='abstract')? )
    ('<' typeParameters+=JvmTypeParameter (',' typeParameters+=JvmTypeParameter)* '>')?
    returnType=JvmTypeReference simpleName=ID
    BRACE_OPEN (parameters+=JvmFormalParameter (',' parameters+=JvmFormalParameter)*)? BRACE_CLOSE
    ('throws' exceptions+=JvmTypeReference (',' exceptions+=JvmTypeReference)*)?
    expression=XBlockExpression
;

enum Visibility returns types::JvmVisibility:
    PUBLIC = 'public' | PROTECTED = 'protected' | PRIVATE = 'private';


//////////////////////////////////
// Template things
//////////////////////////////////

Template returns types::JvmOperation:
    {Template}
    DIRECTIVE_TEMPLATE simpleName=ID BRACE_OPEN (parameters+=JvmFormalParameter (',' parameters+=JvmFormalParameter)*)? BRACE_CLOSE
    expression=RichString
    DIRECTIVE_END
;

Parameter returns types::JvmFormalParameter:
   parameterType=JvmTypeReference name=ID
;

RichString returns xbase::XBlockExpression:
    {RichString}
    ( expressions+=RichStringPart
        | DIRECTIVE startScript+=BRACE_OPEN (expressions+=XExpressionInsideBlock ';')* endScript+=BRACE_CLOSE
    )*
;

RichStringPart returns xbase::XExpression:
      RichStringLiteral
    | RichStringInlineExpr
    | RichStringForLoop
    | RichStringIf
;

RichStringLiteral returns xbase::XStringLiteral:
    {RichStringLiteral} value=TEXT
;

RichStringInlineExpr returns xbase::XExpression:
    {RichStringInlineExpr}
    (DIRECTIVE_ECHO | elvis?=DIRECTIVE_ECHO_ELVIS) BRACE_OPEN expr=XExpression BRACE_CLOSE
;

RichStringForLoop returns xbase::XForLoopExpression:
    {RichStringForLoop}
    DIRECTIVE_FOR BRACE_OPEN declaredParam=JvmFormalParameter ':' forExpression=XExpression BRACE_CLOSE
        eachExpression=RichString
    DIRECTIVE_END
;

RichStringIf returns xbase::XIfExpression:
    {RichStringIf}
    DIRECTIVE_IF BRACE_OPEN if=XExpression BRACE_CLOSE
        then=RichString
    (else=RichStringElseIf | DIRECTIVE_ELSE else=RichString)?
    DIRECTIVE_END
;

RichStringElseIf returns xbase::XIfExpression:
    {RichStringIf}
    DIRECTIVE_ELSEIF BRACE_OPEN if=XExpression BRACE_CLOSE
        then=RichString
    (else=RichStringElseIf | DIRECTIVE_ELSE else=RichString)?
;

QualifiedNameWithWildCard :
    QualifiedName  '.' '*';

terminal BRACE_OPEN: '(';
terminal BRACE_CLOSE: ')';

terminal DIRECTIVE_TEMPLATE: '#template';
terminal DIRECTIVE_IF: '#if';
terminal DIRECTIVE_ELSE: '#else';
terminal DIRECTIVE_ELSEIF: '#elseif';
terminal DIRECTIVE_END: '#end';
terminal DIRECTIVE_FOR: '#for';
terminal DIRECTIVE: '#';
terminal DIRECTIVE_ECHO: '$';
terminal DIRECTIVE_ECHO_ELVIS: '$!';

terminal TEXT:
// we fake the generated parser so it never match it and we can handle it ourself
    '\uAAAA'
// actual expected form:
//    ( (!('#'|'$')) | '##' | '$$')*
;
