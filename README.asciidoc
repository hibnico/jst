JST - Java Simple Template
==========================

JST is a simple template engine which use Java as its programming language and produces Java files to be called anywhere from your code.

Why Yet Another Template Engine ?
---------------------------------

Lot's of template engines try to enforce the MVC pattern (Model View Controller) by limitting the algorithmic features of the language used in the templates. Whereas MVC is definitively a good pattern to avoid writing messy software, the philosophy of JST is to let to the developper the responsability to making the separation of the model and the view, not the template engine.

Unlike some template engine, JST is only targeted to the Java environment. The goal is to have a better integration between a business model and the view. Since both are of the same enviroment, they can shares types, and refactoring can be done more easily.

JST can be compared to JSP. But JST doesn't need you to run in a J2EE framework, JST is just about plain Java.

It can be also be compared to the template engine from Playframework 2, since a JST template produces a class callable from your code. But JST don't need a framework, and don't need scala.

The syntax of JST is quite closed to the Velocity one, because it is a nicely concise syntax. But unlike Velocity, JST is typed and properly scoped, no weird side effect in sight.

Last but not least, JST is based on Xtext. Which means an Eclipse editor is already available for use, with syntax coloring, semantic highlighting, compilation error reporting, refactoring.

TODO
----

- for(inst; condition; increm): currently for loops can only iterate on +Iterable+ (+for(item : list)+)
- add a servlet option: the Writer would come from the HttpServletResponse and HttpServletRequest would be available in the template
- try catch support ? #renderer cannot thow anything else than IOException for now.

Continuous Integration Build
----------------------------

Build can be found there: https://travis-ci.org/nlalevee/jst

Status: image:https://secure.travis-ci.org/nlalevee/jst.png?branch=master

Dependencies
------------

Once generated, the templates need at runtime:

- commons-lang
- guava
- org.eclipse.xtext.xbase.lib

Template Language
-----------------

NB: the programming language is based on Xbase which is not Java but is close to it. For further documentation about that language, see http://www.eclipse.org/Xtext/documentation.html#xbaseLanguageRef_Introduction

The minimum: define a rendering method in your template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

--------------------------------------
#renderer hello()
  Hello World
#end
--------------------------------------

- +#renderer+ defines a new rendering funtion.
- +hello+ is the name; in your Java code it will be a method called +renderHello+.
- +()+ is then the list or arguments of your rendering method, here empty.
- +#end+ defines when the rendering of the current method ends.

Note: if the name of the renderer is +_+, then the generated Java method will simply be +render+.

Outputing expressions
~~~~~~~~~~~~~~~~~~~~~

In the outputed content, juste use +$(aJavaExpression)+. And to output an empty string rather than +null+ on null values, use +$?(aMaybeNullExpression)+

Exemple:
--------------------------------------
#renderer hello(String name)
  Hello $(name) !
#end
--------------------------------------

Outputting +#+ or +$+
~~~~~~~~~~~~~~~~~~~~~

Just double the letters: +##+ and +$$+

Exemple:
--------------------------------------
#renderer account(int account, int amount)
  Account ##$(account) owns $(amount)$$
#end
--------------------------------------

Escaping and unescaping
~~~~~~~~~~~~~~~~~~~~~~~

When rendering variables into the template, you may want to render your variables in the proper encoding of your generated files. For instance, chevrons should be replaced by +&lt;+ and +&gt;+ in html files. Each expression can be escaped individualy, it overrides the global escaping.

Several encodings are available:

- XML: use +$\xml(...)+ or +$?\xml(...)+
- HTML: use +$\html(...)+ or +$?\html(...)+
- JavaScript: use +$\js(...)+ or +$?\js(...)+
- Java: use +$\java(...)+ or +$?\java(...)+
- CSV: use +$\csv(...)+ or +$?\csv(...)+
- SQL: use +$\sql(...)+ or +$?\sql(...)+

You can also disable the global escaping and output your expression in a raw format. For that, use +$\\(...)+ or +$?\\(...)+

Exemple:
--------------------------------------
#renderer main(String name, String htmlData, String script)
<html><body>
  Hello $\html(name) !
  <p>$\\(htmlData)</p>
  <script>
  $?\js(script)
  </script>
</body></html>
#end
--------------------------------------

Scripting
~~~~~~~~~

To declare variables or just do some Java code, do it within +#{...}+

Exemple:
--------------------------------------
#renderer hello(String name)
  #{ var hello = "Hello " + name.trim() + " !" }
  $(hello)
#end
--------------------------------------

Java Imports
~~~~~~~~~~~~

At the begining of your template, just do like you would do in plain Java, declares your imports.

Exemple:
--------------------------------------
import java.util.List;
#renderer size(List list)
  List size is $(list.size())
#end
--------------------------------------

Loops
~~~~~

Loops are like in Java but with the keywords +#for+, +#while+ or #do, together with +#end+

Exemple:
--------------------------------------
import java.util.List
#renderer list(List list)
  <ul>
  #for (item : list)
    <li>$(item)</li>
  #end
  <ul>
  <ol>
  #{ var count = 0; }
  #while(count < list.size())
    <li>$(count) : $(list.get(count))</li>
    #{ count = count + 1; }
  #end
  </ol>
  <pre>
  #{ var count2 = 0; }
  #do
    -- $(count2) : $(list.get(count2))</li>
    #{ count2 = count2 + 1; }
  #end #while(count2 < list.size())
  </pre>
#end
--------------------------------------

Branching
~~~~~~~~~

To do branching, just like in Java but with the keywords +#if+, +#else+, +#elseif+ and +#end+.

Exemple:
--------------------------------------
import java.util.List
#renderer size(List list)
  #if (list == null)
    The list is null
  #elseif(list.isEmpty())
    The list is empty
  #elseif(list.size() == 1)
    The list contains one element
  #else
    The list contains $(list.size()) elements
  #end
#end
--------------------------------------

Package
~~~~~~~

By default the java class generated will be in the default package, ie the root one. You can specify the package in which it will be generated with teh keyword +package+.

Exemple:
--------------------------------------
package org.acme;

#renderer hello()
  Hello World
#end
--------------------------------------

Note that the JST engine doesn't care about where the jst template is placed. You can place it in a java classpath in a proper package, or just randomly put in some folder. Only the +package+ directive and the name of the file specifies the java class to generate. And actually the jst file is useless at runtime, you don't need to embed it into your jar, you just need the compiled class of the generated Java file.

Template Class
~~~~~~~~~~~~~~

The JST engine will generate a plain Java class named after the template file name. The file name is appended with JstTemplate and the first letter is capitalized to build the name of the generated class. For instance +user.jst+ will generate +UserJstTemplate.java+.

Template Class Hierarchy
^^^^^^^^^^^^^^^^^^^^^^^^

The generated class can implement some interfaces and extend classes. After declaring the imports, the declaration of the template's hierachy is like in java but with the keyword +template+ and without the need to name it.

Exemple:
--------------------------------------
import java.io.Serializable;
import java.util.ArrayList;

template extends ArrayList implements Serializable;

#renderer hello()
  Hello World
#end
--------------------------------------

Abstract Template Class
^^^^^^^^^^^^^^^^^^^^^^^

A template class can also be asbtract. The keyword +abstract+ in front of the keyword +template+ make the class abstract.

Exemple:
--------------------------------------
abstract template;

#renderer hello()
  Hello World
#end
--------------------------------------

Fields and Methods
^^^^^^^^^^^^^^^^^^

Fields and methods can be defined on the template class. It is just regular Java.

Exemple:
--------------------------------------
import java.io.File;

private File path;

private void setPath(File path) {
  this.path = path;
}

#renderer path()
  $(path.getAbsolutePath())
#end
--------------------------------------

Renderer call
~~~~~~~~~~~~~

Within a renderer, another renderer can be called with the directive +#render+. The syntax is like a function call in Java.

Exemple:
--------------------------------------
#renderer hello()
  Hello
  #render name("World")
#end
#renderer name(String n)
  $(n)
#end
--------------------------------------

Abstract Renderer
~~~~~~~~~~~~~~~~~

As the template class, a renderer can be declared abstract. Just add the keyword +abstract+.

Exemple:
--------------------------------------
abstract template;
#renderer body(List<String> list)
  <ul>
  #for(i : list)
    <li>#render item(i)</li>
  #end
  </ul>
#end
#renderer abstract item(String i)
--------------------------------------

Template Options
~~~~~~~~~~~~~~~~

Options are available to modify globally the rendering methods. They are defined in the header of the template, on the line which defines the template. After the keyword +with+ comes a comma separated list of keys and values.

The supported options are:

- +escape+: defines how inline expressions should be escaped by default. Expected value: +''xml''+, +''html''+, +''js''+, +''java''+, +''csv''+, or +''sql''+.
- +servlet+: changes the signature of the rendering method to accept an HttpServletRequest and an HttpServletResponse as parameters. Expected value: +true+ or +false+.

Exemple:
--------------------------------------
template with escape = 'html', servlet = true;
#renderer hello()
  Hello World !
#end
--------------------------------------

Layout pattern
~~~~~~~~~~~~~~

When working with templates, some are designed to be layouts of some other contents. With JST, no special keyword or contruction is required, just use the Object Oriented patterns: composition and inheritance.

If you want to be able to change easily of layout, the recomended relation is composition. The "content" layout will be the one called, which will then itself call the "layout" template. Then, if you have several "content" templates sharing the same layout, the recommended way of sharing it is to use inheritance.

Exemple:

- layout.jst
--------------------------------------
template with escape = 'html';
#renderer header()
<html>
  <body>
    <h1>My website</h1>
#end
#renderer footer()
  </body>
</html>
#end
--------------------------------------
- abstractContent.jst
--------------------------------------
abstract template with escape = 'html';
public LayoutJstTemplate layout;
#renderer _()
  #{ layout.renderHeader(out); }
  #render content()
  #{ layout.renderFooter(out); }
#end
#renderer abstract content()
--------------------------------------
- content.jst
--------------------------------------
template extends AbstractContentJstTemplate with escape = 'html';
#renderer content()
  <p>Hello World !</p>
#end
--------------------------------------
- content2.jst
--------------------------------------
template with escape = 'html';
#renderer content(String name)
  <p>Hello $(name) !</p>
#end
--------------------------------------
- Main.java
--------------------------------------
public class Main {
  public static void main(String[] args) {
    LayoutJstTemplate layout = new LayoutJstTemplate();
    ContentJstTemplate content = new ContentJstTemplate();
    content.layout = layout;
    content.render(new OutputStreamWriter(System.out));

    Content2JstTemplate content2 = new Content2JstTemplate();
    content2.layout = layout;
    content2.render(new OutputStreamWriter(System.out), "John Malkovich");
  }
}
--------------------------------------
