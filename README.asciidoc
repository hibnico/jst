JST - Java Simple Template
==========================

JST is a simple template engine which use Java as its programming language and produces Java files to be called anywhere from your code.

Why Yet Another Template Engine ?
---------------------------------

Lot's of template engines try to enforce the MVC pattern (Model View Controller) by limitting the algorithmic features of the language used in the templates. Whereas MVC is definitively a good pattern to avoid writing messy software, the philosophy of JST is to let to the developper the responsability to making the separation of the model and the view, not the template engine.

Unlike some template engine, JST is only targeted to the Java environment. The goal is to have a better integration between a business model and the view. Since both are of the same enviroment, they can shares types, and refactoring can be done more easily.

JST can be compared to JSP. But JST doesn't need you to run in a J2EE framework, JST is just about plain Java.

It can be also be compared to the template engine from Playframework 2, since a JST template produces a class callable from your code. But JST don't need a framework, and don't need scala.

The syntax of JST is quite closed to the Velocity one, because it is a nicely concise syntax. But unlike Velocity, JST is typed and properly scoped, no weird side effect in sight.

Last but not least, JST is based on Xtext. Which means an Eclipse editor is already available for use, with syntax coloring, semantic highlighting, compilation error reporting, refactoring.

TODO
----

- while, do-while: these loops are not yet implemented
- for(inst; condition; increm): currently for loops can only iterate on +Iterable+ (+for(item : list)+)
- add a servlet option: the Writer would come from the HttpServletResponse and HttpServletRequest would be available in the template
- try catch support ? #renderer cannot thow anything else than IOException for now.

Dependencies
------------

Once generated, the templates need commons-lang at runtime.

Template Language
-----------------

NB: the programming language is based on Xbase which is not Java but is close to it. For further documentation about that language, see http://www.eclipse.org/Xtext/documentation.html#xbaseLanguageRef_Introduction

The minimum: define a rendering method in your template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

--------------------------------------
#renderer hello()
  Hello World
#end
--------------------------------------

- +#renderer+ defines a new rendering funtion.
- +hello+ is the name; in your Java code it will be a method called +renderHello+.
- +()+ is then the list or arguments of your rendering method, here empty.
- +#end+ defines when the rendering of the current method ends.

Outputing expressions
~~~~~~~~~~~~~~~~~~~~~

In the outputed content, juste use +$(aJavaExpression)+. And to output an empty string rather than +null+ on null values, use +$?(aMaybeNullExpression)+

Exemple:
--------------------------------------
#renderer hello(String name)
  Hello $(name) !
#end
--------------------------------------

Outputting +#+ or +$+
~~~~~~~~~~~~~~~~~~~~~

Just double the letters: +##+ and +$$+

Exemple:
--------------------------------------
#renderer account(int account, int amount)
  Account ##$(account) owns $(amount)$$
#end
--------------------------------------

Escaping and unescaping
~~~~~~~~~~~~~~~~~~~~~~~

When rendering variables into the template, you may want to render your variables in the proper encoding of your generated files. For instance, chevrons should be replaced by +&lt;+ and +&gt;+ in html files. Each expression can be escaped individualy, it overrides the global escaping.

Several encodings are available:

- XML: use +$\xml(...)+ or +$?\xml(...)+
- HTML: use +$\html(...)+ or +$?\html(...)+
- JavaScript: use +$\js(...)+ or +$?\js(...)+
- Java: use +$\java(...)+ or +$?\java(...)+
- CSV: use +$\csv(...)+ or +$?\csv(...)+
- SQL: use +$\sql(...)+ or +$?\sql(...)+

You can also disable the global escaping and output your expression in a raw format. For that, use +$\\(...)+ or +$?\\(...)+

Exemple:
--------------------------------------
#renderer main(String name, String htmlData, String script)
<html><body>
  Hello $\html(name) !
  <p>$\\(htmlData)</p>
  <script>
  $?\js(script)
  </script>
</body></html>
#end
--------------------------------------

Scripting
~~~~~~~~~

To declare variables or just do some Java code, do it within +#{...}+

Exemple:
--------------------------------------
#renderer hello(String name)
  #{ var hello = "Hello " + name.trim() + " !" }
  $(hello)
#end
--------------------------------------

Java Imports
~~~~~~~~~~~~

At the begining of your template, just do like you would do in plain Java, declares your imports.

Exemple:
--------------------------------------
import java.util.List;
#renderer size(List list)
  List size is $(list.size())
#end
--------------------------------------

Loops
~~~~~

Loops are like in Java but with the keywords +#for+ and +#end+

Exemple:
--------------------------------------
import java.util.List
#renderer list(List list)
  <ul>
  #for (item : list)
    <li>$(item)</li>
  #end
  <ul>
#end
--------------------------------------

Branching
~~~~~~~~~

To do branching, just like in Java but with the keywords +#if+, +#else+, +#elseif+ and +#end+.

Exemple:
--------------------------------------
import java.util.List
#renderer size(List list)
  #if (list == null)
    The list is null
  #elseif(list.isEmpty())
    The list is empty
  #elseif(list.size() == 1)
    The list contains one element
  #else
    The list contains $(list.size()) elements
  #end
#end
--------------------------------------

Template Class
~~~~~~~~~~~~~~

The JST engine will generate a plain Java class named after the template file name. The file name is appended with JstTemplate and the first letter is capitalized to build the name of the generated class. For instance +user.jst+ will generate +UserJstTemplate.java+.

Template Class Hierarchy
^^^^^^^^^^^^^^^^^^^^^^^^

The generated class can implement some interfaces and extend classes. After declaring the imports, the declaration of the template's hierachy is like in java but with the keyword +template+ and without the need to name it.

Exemple:
--------------------------------------
import java.io.Serializable;
import java.util.ArrayList;

template extends ArrayList implements Serializable;

#renderer hello()
  Hello World
#end
--------------------------------------

Abstract Template Class
^^^^^^^^^^^^^^^^^^^^^^^

A template class can also be asbtract. The keyword +abstract+ in front of the keyword +template+ make the class abstract.

Exemple:
--------------------------------------
abstract template;

#renderer hello()
  Hello World
#end
--------------------------------------

Fields and Methods
^^^^^^^^^^^^^^^^^^

Fields and methods can be defined on the template class. It is just regular Java.

Exemple:
--------------------------------------
import java.io.File;

private File path;

private void setPath(File path) {
  this.path = path;
}

#renderer path()
  $(path.getAbsolutePath())
#end
--------------------------------------

Renderer call
~~~~~~~~~~~~~

Within a renderer, another renderer can be called with the directive +#render+. The syntax is like a function call in Java.

Exemple:
--------------------------------------
#renderer hello()
  Hello
  #render name("World")
#end
#renderer name(String n)
  $(n)
#end
--------------------------------------

Abstract Renderer
~~~~~~~~~~~~~~~~~

As the template class, a renderer can be declared abstract. Just add the keyword +abstract+.

Exemple:
--------------------------------------
abstract template;
#renderer body(List<String> list)
  <ul>
  #for(i : list)
    <li>#render item(i)</li>
  #end
  </ul>
#end
#renderer abstract item(String i)
--------------------------------------

Template Options
~~~~~~~~~~~~~~~~

Options are available to modify globally the rendering methods. They are defined in the header of the template, on the line which defines the template. After the keyword +with+ comes a comma separated list of keys and values.

The supported options are:

- +escape+: defines how inline expressions should be escaped by default. Expected value: +''xml''+, +''html''+, +''js''+, +''java''+, +''csv''+, or +''sql''+.
- +servlet+: changes the signature of the rendering method to accept an HttpServletRequest and an HttpServletResponse as parameters. Expected value: +true+ or +false+.

Exemple:
--------------------------------------
template with escape = 'html', servlet = true;
#renderer hello()
  Hello World !
#end
--------------------------------------

Layout pattern
~~~~~~~~~~~~~~

When working with templates, some are designed to be layouts of some other templates. With JST, no special keyword or contruction is required, just use the Java class hierarchy. The template layout will be an abstract template, and the layouted template will extend it.

Exemple:

- layout.jst
--------------------------------------
import java.util.List;
abstract template;
#renderer body(List<String> list)
  <ul>
  #for(i : list)
    <li>#render item(i)</li>
  #end
  </ul>
#end
#renderer abstract item(String i)
--------------------------------------
- item.jst
--------------------------------------
template extends LayoutJstTemplate;
#renderer item(String i)
  <i>$(i)</i>
#end
--------------------------------------
